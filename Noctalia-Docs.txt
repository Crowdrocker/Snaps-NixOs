
##################### Noctalia Docs Create a Matugen template ########################
This guide walks you through adding a new Matugen template to Noctalia.

# Step 1: Create the Template File
First, create your template file in the Matugen templates directory.
For example, if you’re making one for kitty, create:

Assets/MatugenTemplates/kitty.conf

# Generated by Matugen via Noctalia
color0 {{colors.surface.default.hex}}
color1 {{colors.error.default.hex}}
color2 {{colors.tertiary.default.hex}}
color3 {{colors.secondary.default.hex}}
color4 {{colors.primary.default.hex}}
color5 {{colors.primary.default.hex}}
color6 {{colors.secondary.default.hex}}
color7 {{colors.on_background.default.hex}}
color8 {{colors.outline.default.hex}}
color9 {{colors.secondary_fixed_dim.default.hex}}
color10 {{colors.tertiary_container.default.hex}}
color11 {{colors.surface_container.default.hex}}
color12 {{colors.primary_container.default.hex}}
color13 {{colors.on_primary_container.default.hex}}
color14 {{colors.surface_variant.default.hex}}
color15 {{colors.on_background.default.hex}}

cursor {{colors.primary.default.hex}}
cursor_text_color {{colors.on_surface.default.hex}}

foreground            {{colors.on_surface.default.hex}}
background            {{colors.surface.default.hex}}
selection_foreground  {{colors.on_secondary.default.hex}}
selection_background  {{colors.secondary_fixed_dim.default.hex}}
url_color             {{colors.primary.default.hex}}

Matugen uses template variables to map Material Design 3 colors to different app formats.
You can find all the available variables and their Material 3 mappings in the Matugen wiki.

# Step 2: Add a Settings Toggle
Next, create a setting to control whether this template is generated.
Open Commons/Settings.qml, find the templates JsonObject, and add a new property:

property JsonObject templates: JsonObject {
    // ... existing properties ...
    property bool kitty: false
}

This adds a persistent toggle that defaults to false.

# Step 3: Wire It Into the Config Generator
Now tell the system when to use the new template.
Open Services/AppThemeService.qml and find the predefinedTemplateConfigs object.
Add your template config alongside the existing ones:

"kitty": {
  "input": "kitty.conf",
  "outputs": [{
      "path": "~/.config/kitty/themes/noctalia.conf"
    }],
  "postProcess": () => `${colorsApplyScript} kitty\n`
}

The postProcess function tells the system to run a script after generating the colors, which is useful for reloading the application’s theme.

# Step 4: Show the Toggle Only if the Program Exists
We don’t want to display the toggle if kitty isn’t installed.
Open Services/ProgramCheckerService.qml and:

Add a property to track availability:
property bool kittyAvailable: false

Add an entry to the programsToCheck object:
programsToCheck: {
    // ... existing entries ...
    "kittyAvailable": ["which", "kitty"],
}

This automatically updates kittyAvailable when the program is detected.

# Step 5: Add the UI Toggle
Finally, add the toggle to the settings panel.
Open Modules/SettingsPanel/Tabs/ColorSchemeTab.qml, find the appropriate section (or create one), and insert:

NCheckbox {
    label: "kitty"
    description: ProgramCheckerService.kittyAvailable
        ? "Write ~/.config/kitty/themes/noctalia.conf and reload"
        : "Requires kitty to be installed"
    checked: Settings.data.templates.kitty
    enabled: ProgramCheckerService.kittyAvailable
    opacity: ProgramCheckerService.kittyAvailable ? 1.0 : 0.6
    onToggled: checked => {
        if (ProgramCheckerService.kittyAvailable) {
            Settings.data.templates.kitty = checked
            if (Settings.data.colorSchemes.useWallpaperColors)
                AppThemeService.generateFromWallpaper()
            else if (Settings.data.colorSchemes.generateTemplatesForPredefined)
                AppThemeService.generateFromPredefinedScheme(ColorSchemeService.getCurrentScheme())
        }
    }
}

This checkbox:

Shows a helpful description based on whether kitty is installed
Disables itself automatically if the program isn’t available
Regenerates colors right away when toggled (for both wallpaper and predefined schemes)
How Color Generation Works
Noctalia supports two different color generation modes:

Wallpaper-Based Colors
When Settings.data.colorSchemes.useWallpaperColors is enabled, the system uses Matugen to analyze the current wallpaper and generates a complete Material Design 3 color palette. This palette is then used to generate all enabled templates using the standard Matugen workflow.

Predefined Color Schemes
When wallpaper colors are disabled, Noctalia uses predefined color schemes (like Nord, Dracula, Catppuccin, etc.). For these schemes, the system:

Generates a Material Design 3 palette - Uses ColorsConvert.js helper functions to create a complete Material Design 3 color palette from the predefined scheme’s key colors
Maps predefined colors intelligently - Primary, secondary, tertiary, error, and surface colors from the predefined scheme are used as the foundation
Generates complementary colors - Container colors, “on” colors (for text/icons), surface variants, and outline colors are generated using color theory algorithms
Processes templates directly - Templates are copied and color placeholders are replaced with the generated Material Design 3 colors using sed
This approach ensures that predefined color schemes maintain their authentic look while providing a complete Material Design 3 palette for consistent theming across all applications.

# Terminal Templates

Terminal templates are handled specially - they use predefined color schemes directly for better contrast and readability rather than the generated Material Design 3 palette. This ensures terminal applications have optimal readability with high contrast colors.


##################### Noctalia Docs Create a Bar widget ########################
# Step 1: Create the Widget File
Create a new file at Modules/Bar/Widgets/HelloWorld.qml:

import QtQuick
import QtQuick.Layouts
import qs.Commons
import qs.Services

Rectangle {
  id: root

  // Provided by Bar.qml via NWidgetLoader
  property var screen
  property real scaling: 1.0
  property string widgetId: ""
  property string section: ""
  property int sectionWidgetIndex: -1
  property int sectionWidgetsCount: 0

  // Access your metadata and per-instance settings
  property var widgetMetadata: BarWidgetRegistry.widgetMetadata[widgetId]
  property var widgetSettings: {
    if (section && sectionWidgetIndex >= 0) {
      var widgets = Settings.data.bar.widgets[section]
      if (widgets && sectionWidgetIndex < widgets.length) {
        return widgets[sectionWidgetIndex]
      }
    }
    return {}
  }

  implicitHeight: Math.round(Style.capsuleHeight * scaling)
  implicitWidth: Math.round(120 * scaling)
  radius: Math.round(Style.radiusS * scaling)
  color: Color.mSurfaceVariant
  border.width: Math.max(1, Style.borderS * scaling)
  border.color: Color.mOutline

  RowLayout {
    id: layout
    anchors.fill: parent
    anchors.margins: Style.marginXS * scaling
    spacing: Style.marginXS * scaling

    NText {
      text: widgetSettings.text !== undefined ? widgetSettings.text : (widgetMetadata?.text || "Hello")
      font.pointSize: Style.fontSizeXS * scaling
      font.weight: Style.fontWeightBold
      color: Color.mPrimary
      Layout.alignment: Qt.AlignVCenter | Qt.AlignHCenter
    }
  }
}

# Step 2: Register the Widget in the Registry
Open Services/BarWidgetRegistry.qml and make three small edits:

Add the widget to the widgets map:
"HelloWorld": helloWorldComponent,

Provide defaults in widgetMetadata (this seeds per-instance settings when adding from the UI):
"HelloWorld": {
  "allowUserSettings": true,
  "text": "Hello"
},

Add a Component entry so the registry can instantiate it:
property Component helloWorldComponent: Component {
  HelloWorld {}
}

Example

The text field is just an example of a simple per-widget setting copied to the user’s settings when they add it.

# Step 3: Verify It Shows Up in the BarTab Selector
The Bar settings UI (Modules/SettingsPanel/Tabs/BarTab.qml) reads available widgets from BarWidgetRegistry.getAvailableWidgets() and builds the selector automatically.
Once registered, HelloWorld appears in the add-widget menu for Left/Center/Right sections.

# Step 4: Test the Widget from the Settings Panel
Open Settings → Bar → Widgets Positioning.
In the desired section (Left/Center/Right), click “Add” and select HelloWorld.
Drag to reorder if needed.

# Step 5: Add a Settings UI
To let users change the widget text via the Bar settings dialog, create a settings component and map it.

1) Create Modules/SettingsPanel/Bar/WidgetSettings/HelloWorldSettings.qml:
import QtQuick
import QtQuick.Layouts
import qs.Commons
import qs.Widgets

ColumnLayout {
  // Provided by the dialog loader
  property var widgetData
  property var widgetMetadata

  // Local state – initialize from widgetData with metadata fallback
  property string textValue: widgetData?.text !== undefined ? widgetData.text : (widgetMetadata?.text || "Hello")

  NText {
    text: "HelloWorld Text"
    font.pointSize: Style.fontSizeM * scaling
    font.weight: Style.fontWeightBold
    color: Color.mOnSurface
  }

  NTextInput {
    Layout.fillWidth: true
    placeholderText: "Enter text to display..."
    text: textValue
    onTextChanged: textValue = text
  }

  // Called by the dialog's Apply button
  function saveSettings() {
    // Return a new settings object; preserve other keys
    var updated = Object.assign({}, widgetData)
    updated.text = textValue
    return updated
  }
}

2) Map the settings component in Modules/SettingsPanel/Bar/BarWidgetSettingsDialog.qml:
// Inside loadWidgetSettings() widgetSettingsMap
"HelloWorld": "WidgetSettings/HelloWorldSettings.qml",

Now the gear icon on the widget chip opens a dialog with an input field to edit the text.

Tip

The saveSettings() function ensures your changes are written back into the JSON safely.

# Step 6 (Optional): Add More Settings Later
Add keys under widgetMetadata["HelloWorld"] for new defaults (e.g., icon, color, etc.).
They’ll be copied into a widget instance the first time the user adds it.
To adjust existing instances, the user can edit in the UI if supported, or modify their settings JSON.
This inserts the widget with default settings for first-run configurations.
Existing users won’t be affected unless they reset or remove their settings file.

That’s it! You’ve now built a simple, editable widget for the Bar and exposed it cleanly in the settings UI.

